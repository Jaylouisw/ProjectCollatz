# Collatz Distributed Network v1.0.1# Collatz Distributed Network v1.0.1



[![License: CC BY-NC-SA 4.0](https://img.shields.io/badge/License-CC%20BY--NC--SA%204.0-lightgrey.svg)](https://creativecommons.org/licenses/by-nc-sa/4.0/)**Join the global effort to solve the Collatz Conjecture!**

[![Python 3.8+](https://img.shields.io/badge/python-3.8+-blue.svg)](https://www.python.org/downloads/)

[![Platform](https://img.shields.io/badge/platform-Windows%20%7C%20Linux%20%7C%20macOS-lightgrey)](https://github.com/Jaylouisw/ProjectCollatz)A fully decentralized verification network powered by IPFS, with cryptographic proofs, Byzantine fault tolerance, and permanent public records. **Now with complete future-proofing** - works on any OS and hardware configuration with graceful degradation and protocol independence. Contribute computing power from anywhere and help explore one of mathematics' greatest unsolved problems.

[![Future-Proof](https://img.shields.io/badge/future--proof-✓-brightgreen)](https://github.com/Jaylouisw/ProjectCollatz/wiki/Future-Proofing)

📚 **Get Started:** [DISTRIBUTED_QUICKREF.md](DISTRIBUTED_QUICKREF.md) | **Full Documentation:** [DISTRIBUTED.md](DISTRIBUTED.md) | **Deployment:** [DEPLOYMENT.md](DEPLOYMENT.md)

**Join the global effort to solve the Collatz Conjecture!**

## 🚀 One-Command Install

A fully decentralized verification network with cryptographic proofs, Byzantine fault tolerance, and complete future-proofing. **Works on any OS and hardware configuration** with automatic adaptation and graceful degradation.

### Windows (PowerShell):

📚 **[Get Started](#quick-start)** | **[Wiki Documentation](https://github.com/Jaylouisw/ProjectCollatz/wiki)** | **[Architecture](#architecture)** | **[Installation](#installation)**```powershell

iwr -useb https://raw.githubusercontent.com/Jaylouisw/ProjectCollatz/master/install.ps1 | iex

---```



## 🎯 Choose Your Experience### Linux / macOS:

```bash

### 🔮 **Future-Proof Engine** (Recommended)curl -sSL https://raw.githubusercontent.com/Jaylouisw/ProjectCollatz/master/install.sh | bash

*Cross-platform, hardware-adaptive, protocol-independent*```



```bash### Docker:

python future_proof_engine.py --info    # Check compatibility```bash

python future_proof_engine.py --test    # Verify functionality  docker pull jaylouisw/collatz-network:latest

python future_proof_engine.py          # Join networkdocker run -it jaylouisw/collatz-network

``````



**✅ Perfect for:** Any user, any platform, maximum compatibility### Raspberry Pi & SBCs:

Download pre-built images from [Releases](https://github.com/Jaylouisw/ProjectCollatz/releases)

### 🌐 **Traditional Network Launcher**

*Menu-driven interface for distributed network***→ See [DISTRIBUTED_QUICKREF.md](DISTRIBUTED_QUICKREF.md) for complete installation guide!**



```bash## 📱 Pre-Built SBC Images ![SBC Images](https://img.shields.io/badge/SBC%20Images-automated-brightgreen)

python network_launcher.py

```**Ready-to-use images** for Single Board Computers with Collatz Network pre-installed:



**✅ Perfect for:** Interactive setup, account management, detailed control- **🍓 Raspberry Pi** (all models with both 32-bit and 64-bit OS options where supported)

- **🟠 Orange Pi** (64-bit and 32-bit ARM variants) 

### ⚡ **Direct Worker Mode**- **🪨 Rock Pi** (ARM64 and ARM32 models)

*Command-line worker for advanced users*- **⚡ Odroid** (ARM-based variants)

- **🔧 Any ARM SBC** with Ubuntu support

```bash

python distributed_collatz.py --user-key ./keys/username_private_key.pem**🔄 Auto-Updated:** New images are automatically built on every release using GitHub Actions.

```

**📋 Quick Setup:**

**✅ Perfect for:** Automation, multiple nodes, headless deployment1. **Download** appropriate image from [latest release](https://github.com/Jaylouisw/ProjectCollatz/releases/latest)

2. **Flash** to SD card using [Etcher](https://www.balena.io/etcher/) 

### 🖥️ **Legacy Single-Node**3. **Boot** and wait for auto-setup (5-10 minutes)

*High-performance local verification*4. **SSH** in and run: `cd ~/collatz-network && python3 network_launcher.py`

5. **Join** the network: Create account → Start worker → Contribute computing power!

```bash

python CollatzEngine.py---

```

## Features

**✅ Perfect for:** Local testing, GPU benchmarking, research

**🌐 Fully Decentralized Network**

---- No central server - runs forever via IPFS peer-to-peer gossip

- Network continues with n>0 active nodes

## 🚀 Quick Start- Self-organizing work generation

- Permanent public verification records

### 1. **One-Command Install**

**🔐 Cryptographic Security**

**Windows (PowerShell):**- Ed25519 signatures prevent tampering

```powershell- 3+ worker consensus required

iwr -useb https://raw.githubusercontent.com/Jaylouisw/ProjectCollatz/master/install.ps1 | iex- Random work assignment prevents collusion

```- Trust & reputation system with automatic bad-actor detection

- Anti-self-verification prevents single-node attacks

**Linux/macOS:**

```bash**🔮 Future-Proof Architecture (NEW in v1.0.1)**

curl -sSL https://raw.githubusercontent.com/Jaylouisw/ProjectCollatz/master/install.sh | bash- **Protocol Independence**: IPFS now, libp2p ready, any future protocol

```- **Hardware Abstraction**: CPU always works, GPU optional, future accelerators ready

- **Cross-Platform**: Windows/Linux/macOS with automatic compatibility detection

**Docker:**- **Dependency Flexibility**: Version ranges prevent breakage from updates

```bash- **Graceful Degradation**: System works even with missing optional components

docker pull jaylouisw/collatz-network:latest

docker run -it jaylouisw/collatz-network**🎉 Community Features**

```- User accounts with persistent identity

- Global leaderboard on IPFS

### 2. **Check System Compatibility**- Counterexample celebration with network voting

```bash- Credit system for contributors

python future_proof_engine.py --info- Raspberry Pi and Docker support

```

**⚡ High Performance**

### 3. **Run Quick Test**- Multi-backend compute engine (CPU/CUDA/ROCm auto-selection)

```bash- Multi-node horizontal scaling

python future_proof_engine.py --test- Automatic hardware optimization

```- ~10 billion numbers/sec per GPU node



### 4. **Start Contributing****→ See [DISTRIBUTED.md](DISTRIBUTED.md) for complete architecture details!**

```bash

python future_proof_engine.py---

```

## Quick Start

**That's it!** The system automatically detects your hardware, selects optimal protocols, and joins the global network.

### 1. Install (Choose One Method)

---

**Windows:**

## 🏗️ Architecture```powershell

iwr -useb https://raw.githubusercontent.com/Jaylouisw/ProjectCollatz/master/install.ps1 | iex

### **Layered Future-Proof Design**```



```**Linux / macOS:**

┌─────────────────────────────────────────────────────────────────┐```bash

│                    USER INTERFACES                             │curl -sSL https://raw.githubusercontent.com/Jaylouisw/ProjectCollatz/master/install.sh | bash

├─────────────────┬─────────────────┬─────────────────┬───────────┤```

│ Future-Proof    │ Network         │ Direct Worker   │ Legacy    │

│ Engine          │ Launcher        │ Mode           │ Mode      │**Docker:**

│ (Recommended)   │ (Interactive)   │ (Advanced)     │ (Local)   │```bash

└─────────────────┴─────────────────┴─────────────────┴───────────┘docker pull jaylouisw/collatz-network:latest

┌─────────────────────────────────────────────────────────────────┐docker run -it jaylouisw/collatz-network

│                FUTURE-PROOFING ABSTRACTION LAYER               │```

├─────────────────┬─────────────────┬─────────────────────────────┤

│ Network         │ Compute         │ Configuration               │**Raspberry Pi:**

│ Transport       │ Engine          │ Manager                     │Download pre-built image from [Releases](https://github.com/Jaylouisw/ProjectCollatz/releases)

│                 │                 │                             │

│ • IPFS (now)    │ • CPU (always)  │ • Schema validation         │### 2. Create User Account

│ • libp2p (ready)│ • CUDA (opt)    │ • Version migration         │

│ • Future protos │ • ROCm (ready)  │ • Environment overrides     │```bash

│ • Auto-select   │ • Auto-detect   │ • Forward compatibility     │python network_launcher.py

└─────────────────┴─────────────────┴─────────────────────────────┘# Choose option 4: Create User Account

┌─────────────────────────────────────────────────────────────────┐```

│                    DISTRIBUTED NETWORK CORE                    │

├─────────────────┬─────────────────┬─────────────────┬───────────┤Your account gives you:

│ IPFS            │ Trust &         │ Cryptographic   │ Work      │- ✅ Persistent identity across all your nodes

│ Coordinator     │ Consensus       │ Verification    │ Engine    │- ✅ Recognition on the global leaderboard

│                 │                 │                 │           │- ✅ Credit if you find a counterexample!

│ • Work dispatch │ • Reputation    │ • Ed25519 sigs  │ • GPU     │

│ • Progress sync │ • 3+ consensus  │ • Proof chains  │ • CPU     │### 3. Start Contributing

│ • Node discovery│ • Bad actors    │ • Tamper-proof  │ • Ranges  │

│ • Fault handling│ • Anti-self     │ • Public record │ • Results │```bash

└─────────────────┴─────────────────┴─────────────────┴───────────┘python network_launcher.py

```# Choose option 1: Start Worker Node (with account)

```

### **Key Innovations**

Your node will:

**🔮 Future-Proofing (v1.0.1)**- Connect to the global IPFS network

- **Protocol Independence**: IPFS now, libp2p ready, any future protocol- Get randomly assigned verification work

- **Hardware Abstraction**: CPU/GPU/future accelerators with auto-detection- Build trust/reputation over time

- **Configuration Evolution**: Automatic migration, forward compatibility- Contribute to mathematical history!

- **Cross-Platform**: Windows/Linux/macOS with graceful degradation

**That's it!** Your node is now part of the distributed verification network.

**🔒 Security & Trust**

- **Anti-Self-Verification**: Nodes cannot verify their own work### 4. Future-Proof Engine (NEW in v1.0.1)

- **Byzantine Fault Tolerance**: Handles up to 33% malicious nodes

- **Cryptographic Proofs**: Ed25519 signatures prevent tamperingTry the new future-proofed engine with cross-platform compatibility:

- **Consensus Requirements**: 3+ independent verifications per range

```bash

**🌐 Decentralized Network**# Check system compatibility

- **No Central Server**: Runs forever via IPFS peer-to-peer coordinationpython future_proof_engine.py --info

- **Self-Organizing**: Automatic work distribution and progress tracking

- **Permanent Records**: All verifications stored publicly on IPFS# Run functionality test

- **Global Leaderboard**: Community recognition and contribution trackingpython future_proof_engine.py --test



---# Start in local mode (works offline)

python future_proof_engine.py --local

## 🖥️ Platform Support

# Full distributed mode with auto-detection

### **✅ Compatibility Matrix**python future_proof_engine.py

```

| Platform | Architecture | Python | Network | Compute | Status |

|----------|-------------|---------|---------|---------|---------|The future-proof engine automatically:

| **Windows** | x64 | 3.8+ | ✅ IPFS/Auto | ✅ CPU/CUDA | **Verified ✓** |- ✅ Detects your hardware (CPU/GPU) and uses the best available

| **Windows** | ARM64 | 3.8+ | ✅ IPFS/Auto | ✅ CPU/GPU | **Supported** |- ✅ Selects optimal network transport (IPFS/local/future protocols)

| **Linux** | x64 | 3.8+ | ✅ IPFS/Auto | ✅ CPU/CUDA/ROCm | **Supported** |- ✅ Handles missing dependencies gracefully

| **Linux** | ARM64 | 3.8+ | ✅ IPFS/Auto | ✅ CPU/GPU | **Supported** |- ✅ Works across all platforms and architectures

| **macOS** | Intel | 3.8+ | ✅ IPFS/Auto | ✅ CPU/Metal | **Supported** |

| **macOS** | Apple Silicon | 3.8+ | ✅ IPFS/Auto | ✅ CPU/Metal | **Supported** |---

| **Docker** | Multi-arch | 3.8+ | ✅ IPFS/Auto | ✅ Auto-detect | **Supported** |

## Platform Support

### **🔧 Hardware Compatibility**

**✅ Future-Proofed Compatibility Matrix:**

**CPU-Only Systems:**

- ✅ **Always works** - Universal fallback mode| Platform | Architecture | Python | Network | Compute | Status |

- ✅ **No dependencies** - Pure Python implementation|----------|-------------|---------|---------|---------|---------|

- ✅ **Multi-core** - Automatic parallelization| **Windows** | x64 | 3.8+ | ✅ IPFS | ✅ CPU/CUDA | **VERIFIED** |

| **Windows** | ARM64 | 3.8+ | ✅ IPFS | ✅ CPU/GPU | **SUPPORTED** |

**GPU Acceleration:**| **Linux** | x64 | 3.8+ | ✅ IPFS | ✅ CPU/CUDA/ROCm | **SUPPORTED** |

- ✅ **NVIDIA CUDA** - 10x-100x performance boost| **Linux** | ARM64 | 3.8+ | ✅ IPFS | ✅ CPU/GPU | **SUPPORTED** |

- 🔄 **AMD ROCm** - Infrastructure ready| **macOS** | Intel | 3.8+ | ✅ IPFS | ✅ CPU/Metal | **SUPPORTED** |

- 🔄 **Intel GPU** - OpenCL support ready| **macOS** | Apple Silicon | 3.8+ | ✅ IPFS | ✅ CPU/Metal | **SUPPORTED** |

- 🔄 **Apple Silicon** - Metal compute ready| **Docker** | Any | 3.8+ | ✅ IPFS | ✅ Auto-detect | **SUPPORTED** |

| **Raspberry Pi** | ARM64/32 | 3.8+ | ✅ IPFS | ✅ CPU | **SUPPORTED** |

**Future Hardware:**

- ✅ **Extensible** - Plugin architecture for new accelerators**🔧 Hardware Support:**

- ✅ **Auto-detection** - Automatically uses best available- **CPU-Only**: Always works (universal fallback)

- ✅ **Graceful fallback** - Always degrades to working configuration- **NVIDIA GPU**: CUDA acceleration when available

- **AMD GPU**: ROCm acceleration (ready)

---- **Intel GPU**: OpenCL support (ready)

- **Apple Silicon**: Metal compute (ready)

## ⚡ Performance- **Future Hardware**: Extensible plugin architecture



### **Verification Rates****📦 Requirements:**

- **CPU-only**: ~1 million numbers/second- Python 3.8+ (flexible version ranges)

- **GPU (CUDA)**: ~10 billion numbers/second- 2GB RAM minimum (4GB+ recommended) 

- **Multi-node**: Linear scaling with node count- Network transport (IPFS primary, fallbacks available)

- Internet connection (optional for local testing)

### **Network Efficiency**

- **Work Distribution**: Sub-second job assignment**🚀 Performance Modes:**

- **Consensus**: 3+ independent verifications- **Local Mode**: Works offline for testing

- **Fault Recovery**: Automatic reassignment on node failure- **Network Mode**: Full distributed operation

- **Progress Sync**: Real-time global progress tracking- **Hybrid Mode**: Network + local verification



### **Resource Usage**---

- **Memory**: 2GB minimum, 4GB+ recommended

- **Disk**: <100MB for software, minimal for data## Documentation

- **Network**: Minimal bandwidth usage via IPFS

- **Power**: CPU-efficient algorithms, GPU-optional**📚 User Guides:**

- **[DISTRIBUTED_QUICKREF.md](DISTRIBUTED_QUICKREF.md)** - Quick reference guide

---- **[DISTRIBUTED.md](DISTRIBUTED.md)** - Complete network architecture

- **[DEPLOYMENT.md](DEPLOYMENT.md)** - Production deployment guide

## 🔐 Security & Trust- **[USER_ACCOUNTS.md](USER_ACCOUNTS.md)** - User account system

- **[ERROR_HANDLING.md](ERROR_HANDLING.md)** - Troubleshooting

### **Multi-Layer Security**

**🔒 Security & Future-Proofing (NEW):**

1. **Anti-Self-Verification**- **[COMPREHENSIVE_SECURITY_ANALYSIS.md](COMPREHENSIVE_SECURITY_ANALYSIS.md)** - Complete security documentation

   - Nodes cannot verify their own work- **[FUTURE_PROOFING_COMPLETE.md](FUTURE_PROOFING_COMPLETE.md)** - Future-proofing implementation guide

   - Prevents single-node attacks- **[FUTURE_PROOFING_ANALYSIS.md](FUTURE_PROOFING_ANALYSIS.md)** - Technical analysis of future-proofing measures

   - Enforces distributed consensus

---

2. **Byzantine Fault Tolerance**

   - Handles up to 33% malicious nodes## Advanced Topics

   - Multiple verification requirements

   - Automatic bad-actor detection### Manual Installation



3. **Cryptographic Integrity**If you prefer not to use the install scripts:

   - Ed25519 digital signatures

   - Tamper-proof result chains```bash

   - Public verification on IPFS# Install IPFS

# Download from: https://docs.ipfs.tech/install/

4. **Trust System**

   - Reputation-based node scoring# Clone repository

   - Trust levels: UNTRUSTED → VERIFIED → TRUSTED → ELITEgit clone https://github.com/Jaylouisw/ProjectCollatz.git

   - Automatic reputation decay for inactive nodescd ProjectCollatz



5. **Consensus Mechanisms**# Install Python dependencies

   - 3+ independent verifications requiredpip install -r requirements_distributed.txt

   - Conflict resolution protocols

   - Cross-verification between nodes# Start IPFS daemon

ipfs init

6. **Rate Limiting & DoS Protection**ipfs daemon &

   - Request rate limiting

   - Resource usage monitoring# Run the launcher

   - Automatic bad-actor isolationpython network_launcher.py

```

---

### Multi-Node Setup

## 🎉 Community Features

Run multiple worker nodes under one account:

### **User Accounts**

- **Persistent Identity**: Recognition across all your contributions```bash

- **Global Leaderboard**: Community rankings and statistics# Terminal 1

- **Credit System**: Attribution if you find a counterexamplepython distributed_collatz.py --user-key ./keys/user_alice_private.pem --name node1

- **Multi-Node Support**: Run multiple workers under one account

# Terminal 2  

### **Network Statistics**python distributed_collatz.py --user-key ./keys/user_alice_private.pem --name node2

- **Real-time Progress**: Current verification status

- **Node Metrics**: Active workers, performance statistics# Terminal 3

- **Historical Data**: Long-term progress trackingpython distributed_collatz.py --user-key ./keys/user_alice_private.pem --name node3

- **Public Records**: All verifications permanently stored```



### **Counterexample Handling**All nodes contribute to your total statistics!

- **Automatic Detection**: Special handling for potential counterexamples

- **Network Voting**: Community verification of findings### GPU Acceleration

- **Credit Attribution**: Recognition for discoverers

- **Historical Archive**: Permanent record of all findingsFor 10x-100x speedup, install GPU support:



---```bash

# CUDA 12.x

## 🐳 Deployment Optionspip install cupy-cuda12x



### **Docker (Recommended for Servers)**# CUDA 11.x

```bashpip install cupy-cuda11x

# Quick start```

docker run -it jaylouisw/collatz-network

Then start workers normally - GPU will be auto-detected and used.

# Production deployment

docker-compose up -d### Docker Deployment



# Custom configuration```bash

docker run -v ./config:/app/config jaylouisw/collatz-network# Single node

```docker run -d --name collatz-worker \

  -v collatz-ipfs:/home/collatz/.ipfs \

### **Raspberry Pi & Single Board Computers**  -v $PWD/keys:/app/keys:ro \

Pre-built images available: [Releases](https://github.com/Jaylouisw/ProjectCollatz/releases)  jaylouisw/collatz-network \

  python distributed_collatz.py --user-key /app/keys/user_alice_private.pem

**Supported SBCs:**

- 🍓 Raspberry Pi (all models)# Multi-node network

- 🟠 Orange Pi seriesdocker-compose up -d

- 🪨 Rock Pi series```

- ⚡ Odroid series

- 🔧 Any ARM64/ARM32 with UbuntuSee [DEPLOYMENT.md](DEPLOYMENT.md) for complete Docker guide.



### **Cloud Deployment**---

```bash

# AWS/GCP/Azure## How It Works

curl -sSL https://raw.githubusercontent.com/Jaylouisw/ProjectCollatz/master/install.sh | bash

### The Collatz Conjecture

# Kubernetes

kubectl apply -f k8s/collatz-deployment.yamlTake any positive integer:

```- If even: divide by 2

- If odd: multiply by 3 and add 1

---- Repeat until you reach 1



## 🛠️ Development**The conjecture:** Every number eventually reaches 1.



### **Project Components****Status:** Unproven! Verified up to 2^68 by previous efforts.



**Core Engines:****Our goal:** Extend verification further AND create permanent, trustworthy records.

- `future_proof_engine.py` - Modern cross-platform launcher

- `network_launcher.py` - Traditional interactive launcher### The Distributed Network

- `distributed_collatz.py` - Worker node implementation

- `CollatzEngine.py` - High-performance verification engine1. **Work Generation:** Network automatically generates verification tasks

2. **Random Assignment:** Workers randomly selected to prevent collusion

**Future-Proofing Layer:**3. **Verification:** Each range verified by 3+ independent workers

- `network_transport.py` - Protocol-agnostic networking4. **Consensus:** Results must agree (Byzantine fault tolerance)

- `compute_engine.py` - Hardware-agnostic computing5. **Publication:** Cryptographically signed results stored permanently on IPFS

- `config_manager.py` - Configuration management6. **Trust Building:** Workers build reputation through consistent correct results



**Network Components:**If a counterexample is found:

- `ipfs_coordinator.py` - Decentralized work coordination1. 🎉 Network-wide celebration with full credit to finder

- `trust_system.py` - Reputation and consensus2. 🗳️ Democratic vote on whether to continue

- `proof_verification.py` - Cryptographic verification3. 📜 Permanent record of the discovery on IPFS

- `user_account.py` - Account management system

### Why IPFS?

**Support Systems:**

- `error_handler.py` - Comprehensive error handling- **Decentralized:** No single point of failure

- `contribution_tracker.py` - Credit and statistics- **Permanent:** Content-addressed storage lasts forever

- `leaderboard_generator.py` - Community rankings- **Tamper-proof:** Cryptographic hashing prevents alterations

- `counterexample_handler.py` - Special case handling- **Global:** Anyone can verify results independently



### **Testing & Validation**---

```bash

# System compatibility check## Contributing

python future_proof_engine.py --info

Ways to contribute:

# Functionality test

python future_proof_engine.py --test1. **Run a worker node** - Add computing power to the network

2. **Run multiple nodes** - Scale horizontally for more impact

# Comprehensive future-proofing validation3. **Report issues** - Help improve the system

python test_future_proofing.py4. **Share the project** - Grow the network

5. **Code contributions** - Submit PRs for improvements

# Performance benchmarking

python benchmark.pySee [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.



# System diagnostics---

python run_diagnostics.py

```## Performance Benchmarks



---**Per-Node Performance:**

- CPU-only: ~100-500 million numbers/sec (varies by CPU)

## 📚 Documentation- Single GPU: ~10 billion numbers/sec (mid-range GPU)

- Multi-GPU: Scales linearly

### **Quick References**

- **[GitHub Wiki](https://github.com/Jaylouisw/ProjectCollatz/wiki)** - Comprehensive documentation**Network Performance:**

- **[Installation Guide](https://github.com/Jaylouisw/ProjectCollatz/wiki/Installation)** - Setup instructions- 10 nodes: ~100+ billion numbers/sec

- **[User Guide](https://github.com/Jaylouisw/ProjectCollatz/wiki/User-Guide)** - How to participate- 100 nodes: ~1+ trillion numbers/sec

- **[Architecture](https://github.com/Jaylouisw/ProjectCollatz/wiki/Architecture)** - Technical details- Scales indefinitely with more participants!



### **Advanced Topics****Current Progress:**

- **[Future-Proofing](https://github.com/Jaylouisw/ProjectCollatz/wiki/Future-Proofing)** - Cross-platform compatibility- Check network statistics: `python network_launcher.py` → option 9

- **[Security](https://github.com/Jaylouisw/ProjectCollatz/wiki/Security)** - Trust and verification- View leaderboard: `python user_account.py leaderboard`

- **[Deployment](https://github.com/Jaylouisw/ProjectCollatz/wiki/Deployment)** - Production setup

- **[Development](https://github.com/Jaylouisw/ProjectCollatz/wiki/Development)** - Contributing code---



### **Troubleshooting**## FAQ

- **[Common Issues](https://github.com/Jaylouisw/ProjectCollatz/wiki/Troubleshooting)** - Solutions and fixes  

- **[Performance](https://github.com/Jaylouisw/ProjectCollatz/wiki/Performance)** - Optimization tips**Q: Do I need a powerful computer?**

- **[Network Issues](https://github.com/Jaylouisw/ProjectCollatz/wiki/Network-Issues)** - IPFS and connectivityA: No! CPU-only mode works fine. Any contribution helps.



---**Q: How much internet bandwidth does this use?**

A: Very little. IPFS gossip is efficient, typically <1 MB/hour.

## 🤝 Contributing

**Q: Can I run this on a Raspberry Pi?**

We welcome contributions! The Collatz Conjecture is one of mathematics' greatest unsolved problems, and every contribution matters.A: Yes! We provide pre-built Pi images. Perfect for 24/7 operation.



### **Ways to Contribute****Q: What if I find a counterexample?**

- **Join the Network**: Run worker nodes and contribute computing powerA: 🎉 You'll be credited! The network celebrates and votes on continuation.

- **Improve Code**: Submit pull requests for enhancements

- **Report Issues**: Help identify bugs and compatibility problems**Q: Is this safe to run?**

- **Documentation**: Improve guides and explanationsA: Yes. Open source, no data collection, no crypto mining. Just math!

- **Testing**: Validate on new platforms and configurations

**Q: How do I know my contribution matters?**

### **Development Setup**A: Check your statistics and the leaderboard. Every number counts!

```bash

git clone https://github.com/Jaylouisw/ProjectCollatz.git**Q: Can I stop and restart anytime?**

cd ProjectCollatzA: Yes! Your progress and reputation persist across sessions.

pip install -r requirements_distributed.txt

python future_proof_engine.py --test---

```

## License

---

This project is licensed under CC BY-NC-SA 4.0 (Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International).

## 📄 License

**You are free to:**

This project is licensed under [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/):- Share and adapt the work

- ✅ **Share** - Copy and redistribute- Run the distributed network

- ✅ **Adapt** - Remix, transform, and build upon- Modify for personal/educational use

- ⚠️ **Attribution** - Credit must be given

- ⚠️ **NonCommercial** - Not for commercial use**Under these terms:**

- ⚠️ **ShareAlike** - Distribute under same license- Attribution required

- Non-commercial use only

### **Copyright**- Share-alike (derivatives under same license)

Copyright (c) 2025 Jay Wenden (CollatzEngine)

See [LICENSE](LICENSE) for full details.

---

---

## 🌟 About the Collatz Conjecture

## Support

The **Collatz Conjecture** (also known as the 3n+1 problem) is one of the most famous unsolved problems in mathematics:

- **Documentation:** [DISTRIBUTED.md](DISTRIBUTED.md)

> **For any positive integer n:**- **Quick Start:** [DISTRIBUTED_QUICKREF.md](DISTRIBUTED_QUICKREF.md)

> - If n is even: divide by 2- **Deployment:** [DEPLOYMENT.md](DEPLOYMENT.md)

> - If n is odd: multiply by 3 and add 1- **Issues:** https://github.com/Jaylouisw/ProjectCollatz/issues

> - Repeat until reaching 1- **Diagnostics:** `python run_diagnostics.py`

>

> **The conjecture**: This process always reaches 1, no matter what number you start with.---



**Why It Matters:****Ready to contribute?** Install now and join the global verification network! 🚀

- ✨ **Simple to understand** - Anyone can grasp the rules

- 🔍 **Incredibly difficult** - No proof exists after 80+ years## Platform Support

- 🌍 **Computationally intensive** - Verification requires massive computing power

- 🏆 **Mathematical significance** - Could unlock new insights into number theory**Tested & Working:**

- ✅ Windows 10/11 (x64)

**Our Contribution:**- ✅ Ubuntu 20.04/22.04/24.04 (x64, ARM64)

This project provides the first **decentralized, cryptographically verified** approach to systematically explore the conjecture. Every number verified is permanently recorded with cryptographic proof, creating an unalterable record of mathematical progress.- ✅ Debian 11/12 (x64, ARM64)

- ✅ macOS 11+ (Intel & Apple Silicon)

---- ✅ Raspberry Pi OS (ARM64)

- ✅ Docker (all platforms)

## 📊 Current Status

**Requirements:**

### **Network Statistics**- Python 3.8+

- **Active Nodes**: View real-time at our [Global Leaderboard](https://ipfs.io/ipns/collatz-leaderboard)- 2GB RAM minimum (4GB+ recommended)

- **Numbers Verified**: Billions and counting- For distributed network: IPFS daemon

- **Highest Verified**: Check current progress with `python network_launcher.py`- For GPU mode: CUDA-capable GPU

- **Contributors**: Growing global community

## Contributing

### **Recent Milestones**

- ✅ **v1.0.1**: Complete future-proofing implementationWant to help verify the Collatz Conjecture? Join the distributed network above, or contribute code improvements via pull requests.

- ✅ **v1.0.0**: Byzantine fault tolerance and anti-self-verification

- ✅ **Beta**: First decentralized verification network## License

- ✅ **Alpha**: Initial GPU-accelerated verification

Copyright (c) 2025 Jay (CollatzEngine)

### **Roadmap**

- 🔄 **libp2p Integration**: Next-generation P2P networkingThis work is licensed under a [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-nc-sa/4.0/).

- 🔄 **Web Interface**: Browser-based participation

- 🔄 **Mobile Apps**: iOS/Android worker nodes[![CC BY-NC-SA 4.0](https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-nc-sa/4.0/)

- 🔄 **Cloud Integration**: One-click cloud deployment

**You are free to:**

---- **Share** — copy and redistribute the material in any medium or format

- **Adapt** — remix, transform, and build upon the material

**Ready to contribute to mathematical history? [Get started now!](#quick-start)** 🚀

**Under the following terms:**

*"Mathematics is not about numbers, equations, computations, or algorithms: it is about understanding."* - William Paul Thurston- **Attribution** — You must give appropriate credit to Jay (CollatzEngine), provide a link to the license, and indicate if changes were made.
- **NonCommercial** — You may not use the material for commercial purposes.
- **ShareAlike** — If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.

See the [LICENSE](LICENSE) file for full details.

## Acknowledgments

Built with CuPy for CUDA acceleration. Thanks to all GPU benchmark volunteers!
